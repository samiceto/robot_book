#!/usr/bin/env python3
"""
Visualize synthetic datasets with bounding boxes and segmentation masks.

This script loads data generated by Replicator (BasicWriter format) and
displays RGB images with overlaid bounding boxes and class labels.

Usage:
    # Visualize first 10 images from dataset
    python3 visualize_dataset.py \
      --dataset-dir ~/datasets/replicator_output \
      --num-images 10

    # Visualize grasping dataset
    python3 visualize_dataset.py \
      --dataset-dir ~/datasets/grasping_dataset \
      --num-images 20

    # Save visualizations to disk instead of displaying
    python3 visualize_dataset.py \
      --dataset-dir ~/datasets/grasping_dataset \
      --output-dir ~/visualizations \
      --num-images 100
"""

import argparse
import os
import numpy as np
import cv2
import matplotlib.pyplot as plt
import matplotlib.patches as patches

parser = argparse.ArgumentParser(description="Dataset Visualization Tool")
parser.add_argument("--dataset-dir", type=str, required=True,
                    help="Directory containing dataset (Replicator output)")
parser.add_argument("--num-images", type=int, default=10,
                    help="Number of images to visualize")
parser.add_argument("--output-dir", type=str, default=None,
                    help="Save visualizations to directory (optional)")
args = parser.parse_args()

# Expand paths
dataset_dir = os.path.expanduser(args.dataset_dir)
output_dir = os.path.expanduser(args.output_dir) if args.output_dir else None

# Class names and colors
CLASS_COLORS = {
    "cube": (1.0, 0.0, 0.0),      # Red
    "cylinder": (0.0, 1.0, 0.0),   # Green
    "sphere": (0.0, 0.0, 1.0),     # Blue
    "humanoid": (1.0, 1.0, 0.0),   # Yellow
    "table": (0.5, 0.5, 0.5),      # Gray
    "unknown": (1.0, 1.0, 1.0),    # White
}


def load_bounding_boxes(dataset_dir: str):
    """
    Load aggregated bounding boxes from BasicWriter output.

    Args:
        dataset_dir: Directory containing bounding_box_2d_tight.npy

    Returns:
        NumPy structured array with bounding boxes
    """
    bbox_path = os.path.join(dataset_dir, "bounding_box_2d_tight.npy")

    if not os.path.exists(bbox_path):
        print(f"ERROR: Bounding box file not found: {bbox_path}")
        return None

    try:
        data = np.load(bbox_path, allow_pickle=True)
        print(f"Loaded bounding boxes from: {bbox_path}")
        print(f"  Total frames: {len(data)}")
        return data
    except Exception as e:
        print(f"ERROR loading bounding boxes: {e}")
        return None


def load_rgb_image(dataset_dir: str, frame_idx: int):
    """
    Load RGB image for a given frame.

    Args:
        dataset_dir: Dataset directory
        frame_idx: Frame index (0-based)

    Returns:
        NumPy array (H, W, 3) or None if not found
    """
    rgb_path = os.path.join(dataset_dir, f"rgb/rgb_{frame_idx:04d}.png")

    if not os.path.exists(rgb_path):
        print(f"WARNING: RGB image not found: {rgb_path}")
        return None

    # Load with OpenCV (BGR) and convert to RGB
    img = cv2.imread(rgb_path)
    if img is None:
        print(f"ERROR reading image: {rgb_path}")
        return None

    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    return img_rgb


def visualize_frame(rgb_img, bboxes, frame_idx: int, output_dir: str = None):
    """
    Visualize RGB image with overlaid bounding boxes.

    Args:
        rgb_img: RGB image (H, W, 3)
        bboxes: Bounding box data for this frame
        frame_idx: Frame index
        output_dir: Optional directory to save visualization
    """
    fig, ax = plt.subplots(1, 1, figsize=(10, 8))
    ax.imshow(rgb_img)
    ax.axis('off')

    # Parse bounding boxes
    if bboxes is not None and 'data' in bboxes.dtype.names:
        bbox_list = bboxes['data']

        for bbox in bbox_list:
            # BasicWriter format: [x_min, y_min, x_max, y_max]
            x_min, y_min, x_max, y_max = bbox['x_min'], bbox['y_min'], bbox['x_max'], bbox['y_max']

            # Get semantic ID and class name
            semantic_id = bbox.get('semanticId', 0)
            class_name = get_class_name(semantic_id)

            # Get color
            color = CLASS_COLORS.get(class_name, CLASS_COLORS["unknown"])

            # Draw bounding box
            width = x_max - x_min
            height = y_max - y_min
            rect = patches.Rectangle(
                (x_min, y_min), width, height,
                linewidth=2, edgecolor=color, facecolor='none'
            )
            ax.add_patch(rect)

            # Add label
            ax.text(
                x_min, y_min - 5,
                f"{class_name} (ID: {semantic_id})",
                color=color,
                fontsize=10,
                weight='bold',
                bbox=dict(facecolor='black', alpha=0.5)
            )

    ax.set_title(f"Frame {frame_idx}", fontsize=14, weight='bold')

    # Save or display
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)
        output_path = os.path.join(output_dir, f"frame_{frame_idx:04d}.png")
        plt.savefig(output_path, bbox_inches='tight', dpi=150)
        print(f"  Saved: {output_path}")
        plt.close(fig)
    else:
        plt.tight_layout()
        plt.show()


def get_class_name(semantic_id: int):
    """
    Map semantic ID to class name.

    Args:
        semantic_id: Semantic class ID

    Returns:
        Class name string
    """
    # Default mapping (update based on your dataset)
    class_map = {
        0: "background",
        1: "cube",
        2: "cylinder",
        3: "sphere",
        4: "humanoid",
        5: "table",
        6: "ground",
    }
    return class_map.get(semantic_id, "unknown")


def main():
    """Main visualization function."""

    print("=" * 70)
    print("DATASET VISUALIZATION")
    print("=" * 70)
    print(f"Dataset directory: {dataset_dir}")
    print(f"Number of images: {args.num_images}")
    if output_dir:
        print(f"Output directory: {output_dir}")
    else:
        print("Output: Display on screen")
    print("=" * 70)

    # Load bounding boxes
    bbox_data = load_bounding_boxes(dataset_dir)
    if bbox_data is None:
        print("ERROR: Failed to load bounding boxes. Exiting.")
        return

    # Visualize frames
    num_frames = min(args.num_images, len(bbox_data))

    for frame_idx in range(num_frames):
        print(f"\nVisualizing frame {frame_idx}/{num_frames}...")

        # Load RGB image
        rgb_img = load_rgb_image(dataset_dir, frame_idx)
        if rgb_img is None:
            print(f"  Skipping frame {frame_idx} (image not found)")
            continue

        # Get bounding boxes for this frame
        bboxes = bbox_data[frame_idx] if frame_idx < len(bbox_data) else None

        # Visualize
        visualize_frame(rgb_img, bboxes, frame_idx, output_dir)

    print("")
    print("=" * 70)
    print("VISUALIZATION COMPLETE")
    print("=" * 70)
    print(f"Frames visualized: {num_frames}")
    if output_dir:
        print(f"Output directory: {output_dir}")
    print("=" * 70)


if __name__ == "__main__":
    main()
