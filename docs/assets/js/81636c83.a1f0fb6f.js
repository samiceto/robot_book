"use strict";(self.webpackChunkphysical_ai_humanoid_robotics_book=self.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[441],{5022:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"part5-advanced/whole-body-control","title":"Chapter 18: Whole-Body Control","description":"Learning Objectives","source":"@site/docs/part5-advanced/18-whole-body-control.md","sourceDirName":"part5-advanced","slug":"/part5-advanced/whole-body-control","permalink":"/robot_book/docs/part5-advanced/whole-body-control","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":18,"frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"Chapter 17: Bipedal Locomotion","permalink":"/robot_book/docs/part5-advanced/bipedal-locomotion"},"next":{"title":"Chapter 19: Human-Robot Interaction","permalink":"/robot_book/docs/part5-advanced/human-robot-interaction"}}');var i=o(4848),t=o(8453);const a={},l="Chapter 18: Whole-Body Control",s={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"1. Whole-Body Control Overview",id:"1-whole-body-control-overview",level:2},{value:"2. Task-Space Control",id:"2-task-space-control",level:2},{value:"Operational Space Formulation",id:"operational-space-formulation",level:3},{value:"3. Task Prioritization",id:"3-task-prioritization",level:2},{value:"Null-Space Projection",id:"null-space-projection",level:3},{value:"4. Whole-Body Inverse Kinematics",id:"4-whole-body-inverse-kinematics",level:2},{value:"5. Coordinated Behaviors",id:"5-coordinated-behaviors",level:2},{value:"Walk-and-Reach",id:"walk-and-reach",level:3},{value:"6. ROS 2 Integration",id:"6-ros-2-integration",level:2},{value:"7. Hands-On Lab: Walk-and-Grasp (4 hours)",id:"7-hands-on-lab-walk-and-grasp-4-hours",level:2},{value:"8. End-of-Chapter Project",id:"8-end-of-chapter-project",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"chapter-18-whole-body-control",children:"Chapter 18: Whole-Body Control"})}),"\n",(0,i.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Understand"})," hierarchical control for locomotion + manipulation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Implement"})," task-space control with prioritization"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Solve"})," inverse kinematics for redundant robots"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Coordinate"})," arms and legs simultaneously"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Deploy"})," whole-body behaviors in simulation"]}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"1-whole-body-control-overview",children:"1. Whole-Body Control Overview"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Challenge"}),": Control 12+ DOF humanoid to walk AND manipulate simultaneously."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Approach"}),": Hierarchical task prioritization"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Priority 1: Balance (don't fall)\nPriority 2: Locomotion (reach goal)\nPriority 3: Manipulation (grasp object)\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"2-task-space-control",children:"2. Task-Space Control"}),"\n",(0,i.jsx)(e.h3,{id:"operational-space-formulation",children:"Operational Space Formulation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def compute_task_torques(robot_state, desired_task):\n    """\n    Convert task-space goals to joint torques.\n\n    Args:\n        robot_state: Current joint positions/velocities\n        desired_task: End-effector position/orientation\n\n    Returns:\n        Joint torques\n    """\n    # Jacobian: relates joint velocities to task velocities\n    J = robot.compute_jacobian()\n\n    # Task error\n    x_current = robot.forward_kinematics()\n    error = desired_task - x_current\n\n    # Pseudoinverse control\n    dq_desired = np.linalg.pinv(J) @ error\n\n    # PD control in joint space\n    torques = Kp * (dq_desired - robot.q_dot) + Kd * error\n\n    return torques\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"3-task-prioritization",children:"3. Task Prioritization"}),"\n",(0,i.jsx)(e.h3,{id:"null-space-projection",children:"Null-Space Projection"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def prioritized_control(high_priority_task, low_priority_task):\n    """\n    Execute high-priority task, use remaining DOF for low-priority.\n    """\n    # High-priority solution\n    J_high = compute_jacobian(high_priority_task)\n    dq_high = np.linalg.pinv(J_high) @ high_priority_task.error\n\n    # Null-space of high-priority task\n    N = np.eye(n_dof) - np.linalg.pinv(J_high) @ J_high\n\n    # Low-priority solution (projected to null-space)\n    J_low = compute_jacobian(low_priority_task)\n    dq_low = np.linalg.pinv(J_low @ N) @ low_priority_task.error\n\n    # Combined solution\n    dq_total = dq_high + N @ dq_low\n\n    return dq_total\n'})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Example"}),": Walk forward (priority 1) while reaching for cup (priority 2)"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"4-whole-body-inverse-kinematics",children:"4. Whole-Body Inverse Kinematics"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'from scipy.optimize import minimize\n\ndef whole_body_ik(target_positions, joint_limits):\n    """\n    Solve IK for multiple end-effectors.\n\n    Args:\n        target_positions: Dict of {effector_name: target_pos}\n        joint_limits: (min, max) for each joint\n\n    Returns:\n        Optimal joint configuration\n    """\n    def cost(q):\n        # Position error for all end-effectors\n        error = 0\n        for effector, target in target_positions.items():\n            current = forward_kinematics(q, effector)\n            error += np.linalg.norm(current - target)**2\n        return error\n\n    # Optimize\n    result = minimize(\n        cost,\n        x0=current_joints,\n        bounds=joint_limits,\n        method=\'SLSQP\'\n    )\n\n    return result.x\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"5-coordinated-behaviors",children:"5. Coordinated Behaviors"}),"\n",(0,i.jsx)(e.h3,{id:"walk-and-reach",children:"Walk-and-Reach"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"class WalkAndReach:\n    def __init__(self):\n        self.walking_controller = WalkingMPC()\n        self.arm_controller = TaskSpaceController()\n\n    def update(self, dt, target_object):\n        # Priority 1: Maintain balance\n        zmp_command = self.walking_controller.get_zmp_target()\n\n        # Priority 2: Walk toward object\n        distance = np.linalg.norm(target_object.pos - robot.com)\n        if distance > 0.5:  # Not in reach\n            step_command = self.walking_controller.step_toward(target_object)\n        else:\n            step_command = None  # Stop walking\n\n        # Priority 3: Reach for object (if close enough)\n        if distance < 0.8:\n            arm_command = self.arm_controller.reach(target_object)\n        else:\n            arm_command = None\n\n        # Combine commands with prioritization\n        joint_targets = self.combine_tasks(zmp_command, step_command, arm_command)\n\n        return joint_targets\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"6-ros-2-integration",children:"6. ROS 2 Integration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped\nfrom sensor_msgs.msg import JointState\n\nclass WholeBodyController(Node):\n    def __init__(self):\n        super().__init__('whole_body_controller')\n\n        # Subscribers\n        self.create_subscription(PoseStamped, '/target_object', self.object_callback, 10)\n        self.create_subscription(JointState, '/joint_states', self.state_callback, 10)\n\n        # Publisher\n        self.cmd_pub = self.create_publisher(JointState, '/joint_commands', 10)\n\n        # Controllers\n        self.controller = WalkAndReach()\n\n    def object_callback(self, msg):\n        # Update with new target\n        joint_cmds = self.controller.update(0.01, msg.pose)\n\n        # Publish\n        joint_msg = JointState()\n        joint_msg.position = joint_cmds\n        self.cmd_pub.publish(joint_msg)\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"7-hands-on-lab-walk-and-grasp-4-hours",children:"7. Hands-On Lab: Walk-and-Grasp (4 hours)"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Goal"}),": Humanoid walks to table and grasps object."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Implement whole-body IK solver"}),"\n",(0,i.jsx)(e.li,{children:"Create walking controller (from Chapter 17)"}),"\n",(0,i.jsx)(e.li,{children:"Add arm reaching controller"}),"\n",(0,i.jsx)(e.li,{children:"Combine with task prioritization"}),"\n",(0,i.jsx)(e.li,{children:"Test in Isaac Sim: walk 2m, grasp cup"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Validation"}),": Successfully grasp object while maintaining balance"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"8-end-of-chapter-project",children:"8. End-of-Chapter Project"}),"\n",(0,i.jsx)(e.p,{children:"Implement mobile manipulation task (navigate + manipulate)."}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Requirements"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Walk to target location (3 meters)"}),"\n",(0,i.jsx)(e.li,{children:"Avoid obstacles during walking"}),"\n",(0,i.jsx)(e.li,{children:"Reach and grasp object at destination"}),"\n",(0,i.jsx)(e.li,{children:"Carry object while walking back"}),"\n",(0,i.jsx)(e.li,{children:"Success rate >50% over 10 trials"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Deliverables"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Whole-body controller implementation"}),"\n",(0,i.jsx)(e.li,{children:"Simulation video"}),"\n",(0,i.jsx)(e.li,{children:"Performance analysis"}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"Whole-body control enables simultaneous locomotion and manipulation through hierarchical task prioritization and null-space projection. This unlocks mobile manipulation capabilities for humanoid robots."}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Next"}),": Chapter 19 covers human-robot interaction and teleoperation."]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,o)=>{o.d(e,{R:()=>a,x:()=>l});var r=o(6540);const i={},t=r.createContext(i);function a(n){const e=r.useContext(t);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),r.createElement(t.Provider,{value:e},n.children)}}}]);