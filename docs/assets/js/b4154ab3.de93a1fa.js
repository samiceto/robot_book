"use strict";(self.webpackChunkphysical_ai_humanoid_robotics_book=self.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[995],{8453:(n,e,o)=>{o.d(e,{R:()=>r,x:()=>l});var i=o(6540);const t={},s=i.createContext(t);function r(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:r(n.components),i.createElement(s.Provider,{value:e},n.children)}},9859:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"part5-advanced/bipedal-locomotion","title":"Chapter 17: Bipedal Locomotion","description":"Learning Objectives","source":"@site/docs/part5-advanced/17-bipedal-locomotion.md","sourceDirName":"part5-advanced","slug":"/part5-advanced/bipedal-locomotion","permalink":"/robot_book/docs/part5-advanced/bipedal-locomotion","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":17,"frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"Chapter 16: End-to-End Visuomotor Control","permalink":"/robot_book/docs/part4-vla/visuomotor-control"},"next":{"title":"Chapter 18: Whole-Body Control","permalink":"/robot_book/docs/part5-advanced/whole-body-control"}}');var t=o(4848),s=o(8453);const r={},l="Chapter 17: Bipedal Locomotion",a={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"1. Bipedal Stability Fundamentals",id:"1-bipedal-stability-fundamentals",level:2},{value:"Zero Moment Point (ZMP)",id:"zero-moment-point-zmp",level:3},{value:"Center of Mass (CoM)",id:"center-of-mass-com",level:3},{value:"2. Walking Gait Basics",id:"2-walking-gait-basics",level:2},{value:"Gait Phases",id:"gait-phases",level:3},{value:"Trajectory Generation",id:"trajectory-generation",level:3},{value:"3. Model Predictive Control (MPC)",id:"3-model-predictive-control-mpc",level:2},{value:"4. Isaac Sim Implementation",id:"4-isaac-sim-implementation",level:2},{value:"Setup Humanoid",id:"setup-humanoid",level:3},{value:"Walking Controller",id:"walking-controller",level:3},{value:"5. Hands-On Lab: Walking Simulation (3 hours)",id:"5-hands-on-lab-walking-simulation-3-hours",level:2},{value:"6. End-of-Chapter Project",id:"6-end-of-chapter-project",level:2},{value:"Summary",id:"summary",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"chapter-17-bipedal-locomotion",children:"Chapter 17: Bipedal Locomotion"})}),"\n",(0,t.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Understand"})," Zero Moment Point (ZMP) stability criterion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Implement"})," basic walking gait with MPC"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Simulate"})," bipedal walking in Isaac Sim"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Tune"})," gait parameters for stable locomotion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Deploy"})," walking controller to humanoid hardware"]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"1-bipedal-stability-fundamentals",children:"1. Bipedal Stability Fundamentals"}),"\n",(0,t.jsx)(e.h3,{id:"zero-moment-point-zmp",children:"Zero Moment Point (ZMP)"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Definition"}),": Point on ground where total moment from gravity and inertia equals zero."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Stability Criterion"}),": ZMP must stay within support polygon (foot contact area)."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"If ZMP inside foot \u2192 Stable\nIf ZMP outside foot \u2192 Robot will fall\n"})}),"\n",(0,t.jsx)(e.h3,{id:"center-of-mass-com",children:"Center of Mass (CoM)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'def compute_com(link_positions, link_masses):\n    """Compute center of mass position."""\n    total_mass = sum(link_masses)\n    com = sum(pos * mass for pos, mass in zip(link_positions, link_masses))\n    return com / total_mass\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"2-walking-gait-basics",children:"2. Walking Gait Basics"}),"\n",(0,t.jsx)(e.h3,{id:"gait-phases",children:"Gait Phases"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"1. Double Support (both feet on ground)\n2. Single Support (one foot on ground)\n3. Swing Phase (moving foot)\n4. Heel Strike (foot lands)\n"})}),"\n",(0,t.jsx)(e.h3,{id:"trajectory-generation",children:"Trajectory Generation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import numpy as np\n\ndef generate_foot_trajectory(step_length=0.2, step_height=0.05, duration=0.8):\n    """Generate swing foot trajectory (parabola)."""\n    t = np.linspace(0, duration, 100)\n\n    # X: Linear motion forward\n    x = step_length * t / duration\n\n    # Z: Parabolic swing\n    z = 4 * step_height * t / duration * (1 - t / duration)\n\n    return x, z\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"3-model-predictive-control-mpc",children:"3. Model Predictive Control (MPC)"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Idea"}),": Plan future robot states to keep ZMP stable."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class WalkingMPC:\n    def __init__(self, horizon=10):\n        self.horizon = horizon  # Prediction steps\n\n    def solve(self, current_state, zmp_reference):\n        """\n        Solve MPC optimization.\n\n        Returns:\n            Optimal CoM trajectory\n        """\n        # Simplified linear MPC\n        # Minimize: ||CoM - reference||^2 + ||ZMP - zmp_reference||^2\n\n        # Returns next CoM velocity\n        return com_velocity_command\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"4-isaac-sim-implementation",children:"4. Isaac Sim Implementation"}),"\n",(0,t.jsx)(e.h3,{id:"setup-humanoid",children:"Setup Humanoid"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'from omni.isaac.core import World\nfrom omni.isaac.core.robots import Robot\n\nworld = World()\nhumanoid = Robot(prim_path="/World/Humanoid", name="walker")\n\n# Configure ground contact\nground = world.scene.add_default_ground_plane()\n\n# Reset to standing pose\nstanding_joints = [0, 0, 0, -0.2, 0.4, -0.2,  # Left leg\n                   0, 0, 0, -0.2, 0.4, -0.2]  # Right leg\nhumanoid.set_joint_positions(standing_joints)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"walking-controller",children:"Walking Controller"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class WalkingController:\n    def __init__(self):\n        self.phase = 0  # Gait phase (0-1)\n        self.step_time = 0.8  # seconds per step\n\n    def update(self, dt):\n        self.phase += dt / self.step_time\n        if self.phase > 1:\n            self.phase -= 1\n\n        # Generate foot positions\n        left_foot_pos = self.get_foot_position("left", self.phase)\n        right_foot_pos = self.get_foot_position("right", self.phase)\n\n        # Inverse kinematics to get joint angles\n        joint_targets = self.ik_solver(left_foot_pos, right_foot_pos)\n\n        return joint_targets\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"5-hands-on-lab-walking-simulation-3-hours",children:"5. Hands-On Lab: Walking Simulation (3 hours)"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Goal"}),": Implement basic walking in Isaac Sim."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Load humanoid in Isaac Sim"}),"\n",(0,t.jsx)(e.li,{children:"Implement ZMP calculation"}),"\n",(0,t.jsx)(e.li,{children:"Generate walking trajectory"}),"\n",(0,t.jsx)(e.li,{children:"Tune step length (0.1-0.3m) and frequency (0.5-2 Hz)"}),"\n",(0,t.jsx)(e.li,{children:"Achieve 10 consecutive steps without falling"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Validation"}),": Robot walks forward 2 meters stably"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"6-end-of-chapter-project",children:"6. End-of-Chapter Project"}),"\n",(0,t.jsx)(e.p,{children:"Implement outdoor walking with uneven terrain."}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Requirements"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Walking controller with MPC"}),"\n",(0,t.jsx)(e.li,{children:"Terrain adaptation (detect slopes)"}),"\n",(0,t.jsx)(e.li,{children:"Fall recovery behavior"}),"\n",(0,t.jsx)(e.li,{children:"Walk 5 meters on uneven ground in simulation"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Deliverables"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Walking controller code"}),"\n",(0,t.jsx)(e.li,{children:"Simulation video"}),"\n",(0,t.jsx)(e.li,{children:"Performance analysis (stability, speed)"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"Bipedal locomotion requires careful balance control using ZMP stability criterion and MPC for trajectory planning. Isaac Sim enables safe testing of walking gaits before hardware deployment."}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Next"}),": Chapter 18 covers whole-body control for simultaneous locomotion and manipulation."]})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(c,{...n})}):c(n)}}}]);